{"version":3,"file":"nivo-stream.es.js","sources":["../src/StreamLayer.tsx","../src/StreamLayers.tsx","../src/StreamDots.tsx","../src/StreamSlicesItem.tsx","../src/StreamSlices.tsx","../src/props.ts","../src/StreamDotsItem.tsx","../src/LayerTooltip.tsx","../src/StackTooltip.tsx","../src/Stream.tsx","../src/hooks.ts","../src/ResponsiveStream.tsx"],"sourcesContent":["import { useCallback, createElement } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamLayerData } from './types'\n\ninterface StreamLayerProps<RawDatum extends StreamDatum> {\n    layer: StreamLayerData\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayer = <RawDatum extends StreamDatum>({\n    layer,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayerProps<RawDatum>) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { layer }), event, 'left')\n        },\n        [showTooltipFromEvent, layer]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(layer.path)\n    const animatedProps = useSpring({\n        color: layer.color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={layer.fill ? layer.fill : animatedProps.color}\n            fillOpacity={fillOpacity}\n            stroke={getBorderColor(layer)}\n            strokeWidth={borderWidth}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? hideTooltip : undefined}\n        />\n    )\n}\n","import { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { StreamLayer } from './StreamLayer'\nimport { StreamCommonProps, StreamLayerData, StreamDatum } from './types'\n\ninterface StreamLayersProps<RawDatum extends StreamDatum> {\n    layers: StreamLayerData[]\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayers = <RawDatum extends StreamDatum>({\n    layers,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayersProps<RawDatum>) => (\n    <g>\n        {layers.map((layer, i) => (\n            <StreamLayer<RawDatum>\n                key={i}\n                layer={layer}\n                getBorderColor={getBorderColor}\n                borderWidth={borderWidth}\n                fillOpacity={fillOpacity}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n","import { createElement } from 'react'\nimport { StreamSvgProps, StreamLayerDatum, StreamDatum } from './types'\n\ninterface StreamDotsProps<RawDatum extends StreamDatum> {\n    id: string | number\n    color: string\n    data: StreamLayerDatum[]\n    dotComponent: Exclude<StreamSvgProps<RawDatum>['dotComponent'], undefined>\n    position: 'start' | 'center' | 'end'\n    getSize: (datum: StreamLayerDatum) => number\n    getColor: (datum: StreamLayerDatum) => string\n    getBorderWidth: (datum: StreamLayerDatum) => number\n    getBorderColor: (datum: StreamLayerDatum) => string\n}\n\nconst getDotY = <RawDatum extends StreamDatum>(\n    datum: StreamLayerDatum,\n    position: StreamDotsProps<RawDatum>['position']\n) => {\n    let y = datum.y2\n    if (position === 'center') {\n        y = datum.y1 + (datum.y2 - datum.y1) / 2\n    } else if (position === 'start') {\n        y = datum.y1\n    }\n\n    return y\n}\n\nexport const StreamDots = <RawDatum extends StreamDatum>({\n    data,\n    dotComponent,\n    position,\n    getSize,\n    getColor,\n    getBorderWidth,\n    getBorderColor,\n}: StreamDotsProps<RawDatum>) => (\n    <>\n        {data.map((datum, i) => {\n            return createElement(dotComponent, {\n                key: i,\n                datum,\n                x: datum.x,\n                y: getDotY<RawDatum>(datum, position),\n                size: getSize(datum),\n                color: getColor(datum),\n                borderWidth: getBorderWidth(datum),\n                borderColor: getBorderColor(datum),\n            })\n        })}\n    </>\n)\n","import { createElement, useCallback, useState } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamSliceData } from './types'\n\ninterface StreamSlicesItemProps<RawDatum extends StreamDatum> {\n    slice: StreamSliceData\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlicesItem = <RawDatum extends StreamDatum>({\n    slice,\n    height,\n    tooltip,\n}: StreamSlicesItemProps<RawDatum>) => {\n    const [isHover, setIsHover] = useState(false)\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            setIsHover(true)\n            showTooltipFromEvent(createElement(tooltip, { slice }), event, 'left')\n        },\n        [setIsHover, showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [setIsHover, hideTooltip])\n\n    return (\n        <g transform={`translate(${slice.x}, 0)`}>\n            {isHover && (\n                <line\n                    x1={0}\n                    x2={0}\n                    y1={0}\n                    y2={height}\n                    stroke=\"#000\"\n                    strokeOpacity={0.35}\n                    strokeWidth={1}\n                />\n            )}\n            <rect\n                x={-20}\n                width={40}\n                height={height}\n                fill=\"#000\"\n                fillOpacity={0}\n                onMouseEnter={handleMouseHover}\n                onMouseMove={handleMouseHover}\n                onMouseLeave={handleMouseLeave}\n            />\n        </g>\n    )\n}\n","import { StreamSliceData, StreamDatum, StreamCommonProps } from './types'\nimport { StreamSlicesItem } from './StreamSlicesItem'\n\ninterface StreamSlicesProps<RawDatum extends StreamDatum> {\n    slices: StreamSliceData[]\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlices = <RawDatum extends StreamDatum>({\n    slices,\n    height,\n    tooltip,\n}: StreamSlicesProps<RawDatum>) => (\n    <g>\n        {slices.map(slice => (\n            <StreamSlicesItem<RawDatum>\n                key={slice.index}\n                slice={slice}\n                height={height}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n","import { StackOrder, StackOffset, AreaCurve } from '@nivo/core'\nimport { StreamCommonProps, StreamLayerId } from './types'\nimport { StreamDotsItem } from './StreamDotsItem'\nimport { LayerTooltip } from './LayerTooltip'\nimport { StackTooltip } from './StackTooltip'\n\nexport const defaultProps = {\n    label: 'id',\n\n    order: 'none' as StackOrder,\n    offsetType: 'wiggle' as StackOffset,\n    curve: 'catmullRom' as AreaCurve,\n\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n\n    colors: { scheme: 'nivo' } as StreamCommonProps<any>['colors'],\n    fillOpacity: 1,\n    borderWidth: 0,\n    borderColor: {\n        from: 'color',\n        modifiers: [['darker', 1]],\n    } as StreamCommonProps<any>['borderColor'],\n\n    enableDots: false,\n    dotPosition: 'center' as StreamCommonProps<any>['dotPosition'],\n    dotComponent: StreamDotsItem,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n\n    isInteractive: true,\n    tooltip: LayerTooltip,\n    enableStackTooltip: true,\n    stackTooltip: StackTooltip,\n\n    legends: [],\n    legendLabel: 'id',\n\n    role: 'application',\n}\n\nexport const svgDefaultProps = {\n    ...defaultProps,\n    layers: ['grid', 'axes', 'layers', 'dots', 'slices', 'legends'] as StreamLayerId[],\n\n    defs: [],\n    fill: [],\n\n    animate: true,\n    motionConfig: 'default',\n\n    role: 'img',\n    isFocusable: false,\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\n\nexport interface StreamDotsItemProps {\n    x: number\n    y: number\n    size: number\n    color: string\n    borderWidth: number\n    borderColor: string\n}\n\nexport const StreamDotsItem = ({\n    x,\n    y,\n    size,\n    color,\n    borderWidth,\n    borderColor,\n}: StreamDotsItemProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size * 0.5,\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            cx={animatedProps.x}\n            cy={animatedProps.y}\n            r={animatedProps.radius}\n            fill={animatedProps.color}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n        />\n    )\n}\n","import { BasicTooltip } from '@nivo/tooltip'\nimport { TooltipProps } from './types'\n\nexport const LayerTooltip = ({ layer }: TooltipProps) => (\n    <BasicTooltip id={layer.label} enableChip={true} color={layer.color} />\n)\n","import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { StackTooltipProps } from './types'\n\nexport const StackTooltip = ({ slice }: StackTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            slice.stack.map(p => [\n                <Chip key={p.layerId} color={p.color} />,\n                p.layerLabel,\n                p.formattedValue,\n            ]),\n        [slice]\n    )\n\n    return <TableTooltip rows={rows} />\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport {\n    Container,\n    SvgWrapper,\n    useDimensions,\n    // @ts-ignore\n    bindDefs,\n} from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { StreamLayers } from './StreamLayers'\nimport { StreamDots } from './StreamDots'\nimport { StreamSlices } from './StreamSlices'\nimport { useStream } from './hooks'\nimport { svgDefaultProps } from './props'\nimport { StreamDatum, StreamLayerId, StreamSvgProps } from './types'\n\ntype InnerStreamProps<RawDatum extends StreamDatum> = Omit<\n    StreamSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerStream = <RawDatum extends StreamDatum>({\n    data,\n    keys,\n    label,\n    valueFormat,\n\n    offsetType,\n    order,\n    curve,\n\n    layers: chartLayers = svgDefaultProps.layers,\n\n    width,\n    height,\n    margin: partialMargin,\n\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n\n    colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n\n    enableDots = svgDefaultProps.enableDots,\n    dotPosition = svgDefaultProps.dotPosition,\n    dotComponent = svgDefaultProps.dotComponent,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    enableStackTooltip = svgDefaultProps.enableStackTooltip,\n    stackTooltip = svgDefaultProps.stackTooltip,\n\n    legends = svgDefaultProps.legends,\n\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n}: InnerStreamProps<RawDatum>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        xScale,\n        yScale,\n        layers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    } = useStream<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        keys,\n        label,\n        valueFormat,\n        offsetType,\n        order,\n        curve,\n        colors,\n        borderColor,\n        dotSize,\n        dotColor,\n        dotBorderWidth,\n        dotBorderColor,\n    })\n\n    const boundDefs = bindDefs(defs, layers, fill)\n\n    const layerById: Record<StreamLayerId, ReactNode> = {\n        grid: null,\n        axes: null,\n        layers: null,\n        dots: null,\n        slices: null,\n        legends: null,\n    }\n\n    if (chartLayers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (xScale as any) : null}\n                yScale={enableGridY ? (yScale as any) : null}\n            />\n        )\n    }\n\n    if (chartLayers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale as any}\n                yScale={yScale as any}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (chartLayers.includes('layers')) {\n        layerById.layers = (\n            <StreamLayers<RawDatum>\n                key=\"layers\"\n                layers={layers}\n                fillOpacity={fillOpacity}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <Fragment key=\"dots\">\n                {layers.map(layer => (\n                    <StreamDots\n                        key={layer.id}\n                        id={layer.id}\n                        color={layer.color}\n                        data={layer.data}\n                        dotComponent={dotComponent}\n                        position={dotPosition}\n                        getSize={getDotSize}\n                        getColor={getDotColor}\n                        getBorderWidth={getDotBorderWidth}\n                        getBorderColor={getDotBorderColor}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    if (chartLayers.includes('slices') && isInteractive && enableStackTooltip) {\n        layerById.slices = (\n            <StreamSlices<RawDatum>\n                key=\"slices\"\n                slices={slices}\n                height={innerHeight}\n                tooltip={stackTooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => {\n                    const legendData = layers\n                        .map(layer => ({\n                            id: layer.id,\n                            label: layer.label,\n                            color: layer.color,\n                            fill: layer.fill,\n                        }))\n                        .reverse()\n\n                    return (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legend}\n                            containerWidth={innerWidth}\n                            containerHeight={innerHeight}\n                            data={legendData}\n                        />\n                    )\n                })}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {chartLayers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Stream = <RawDatum extends StreamDatum>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: StreamSvgProps<RawDatum>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerStream<RawDatum> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { useMemo } from 'react'\nimport { area, stack as d3Stack } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport {\n    useTheme,\n    usePropertyAccessor,\n    useValueFormatter,\n    useCurveInterpolation,\n    // @ts-ignore\n    stackOrderFromProp,\n    // @ts-ignore\n    stackOffsetFromProp,\n} from '@nivo/core'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport {\n    StreamCommonProps,\n    StreamCustomLayerProps,\n    StreamDataProps,\n    StreamDatum,\n    StreamLayerData,\n    StreamLayerDatum,\n    StreamSliceData,\n} from './types'\nimport { defaultProps } from './props'\n\nexport const useStream = <RawDatum extends StreamDatum>({\n    width,\n    height,\n    data,\n    keys,\n    label = defaultProps.label,\n    valueFormat,\n    offsetType = defaultProps.offsetType,\n    order = defaultProps.order,\n    curve = defaultProps.curve,\n    colors = defaultProps.colors,\n    borderColor = defaultProps.borderColor,\n    dotSize = defaultProps.dotSize,\n    dotColor = defaultProps.dotColor,\n    dotBorderWidth = defaultProps.dotBorderWidth,\n    dotBorderColor = defaultProps.dotBorderColor,\n}: {\n    width: number\n    height: number\n    data: StreamDataProps<RawDatum>['data']\n    keys: StreamDataProps<RawDatum>['keys']\n    label?: StreamCommonProps<RawDatum>['label']\n    valueFormat?: StreamCommonProps<RawDatum>['valueFormat']\n    offsetType?: StreamCommonProps<RawDatum>['offsetType']\n    order?: StreamCommonProps<RawDatum>['order']\n    curve?: StreamCommonProps<RawDatum>['curve']\n    colors?: StreamCommonProps<RawDatum>['colors']\n    dotSize?: StreamCommonProps<RawDatum>['dotSize']\n    dotColor?: StreamCommonProps<RawDatum>['dotColor']\n    dotBorderWidth?: StreamCommonProps<RawDatum>['dotBorderWidth']\n    dotBorderColor?: StreamCommonProps<RawDatum>['dotBorderColor']\n    borderColor?: StreamCommonProps<RawDatum>['borderColor']\n}) => {\n    const areaCurveFactory = useCurveInterpolation(curve)\n    const areaGenerator = useMemo(\n        () =>\n            area<StreamLayerDatum>()\n                .x(({ x }) => x)\n                .y0(({ y1 }) => y1)\n                .y1(({ y2 }) => y2)\n                .curve(areaCurveFactory),\n        [areaCurveFactory]\n    )\n\n    const stack = useMemo(\n        () =>\n            d3Stack<RawDatum, string | number>()\n                .keys(keys)\n                .offset(stackOffsetFromProp(offsetType))\n                .order(stackOrderFromProp(order)),\n        [keys, offsetType, order]\n    )\n\n    const [layers, xScale, yScale] = useMemo(() => {\n        const allMin: number[] = []\n        const allMax: number[] = []\n\n        const layers = stack(data).map(layer => {\n            return layer.map(point => {\n                allMin.push(point[0])\n                allMax.push(point[1])\n\n                return {\n                    ...point,\n                    value: point.data[layer.key] as number,\n                }\n            })\n        })\n\n        const minValue = Math.min(...allMin)\n        const maxValue = Math.max(...allMax)\n\n        return [\n            layers,\n            scalePoint<number>()\n                .domain(Array.from({ length: data.length }, (_, i) => i))\n                .range([0, width]),\n            scaleLinear().domain([minValue, maxValue]).range([height, 0]),\n        ]\n    }, [stack, data, width, height])\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale<Omit<StreamLayerData, 'label' | 'color' | 'data'>>(\n        colors,\n        'id'\n    )\n    const getBorderColor = useInheritedColor<StreamLayerData>(borderColor, theme)\n\n    const getDotSize = useMemo(\n        () => (typeof dotSize === 'function' ? dotSize : () => dotSize),\n        [dotSize]\n    )\n    const getDotColor = useInheritedColor(dotColor, theme)\n    const getDotBorderWidth = useMemo(\n        () => (typeof dotBorderWidth === 'function' ? dotBorderWidth : () => dotBorderWidth),\n        [dotBorderWidth]\n    )\n    const getDotBorderColor = useInheritedColor(dotBorderColor, theme)\n\n    const getLabel = usePropertyAccessor<\n        Omit<StreamLayerData, 'label' | 'color' | 'data'>,\n        string | number\n    >(label)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const enhancedLayers: StreamLayerData[] = useMemo(\n        () =>\n            layers.map((points, layerIndex) => {\n                const computedPoints: StreamLayerDatum[] = points.map((point, i) => ({\n                    layerId: keys[layerIndex],\n                    layerLabel: '',\n                    index: i,\n                    color: '',\n                    x: xScale(i) as number,\n                    value: point.value,\n                    formattedValue: formatValue(point.value),\n                    y1: yScale(point[0]),\n                    y2: yScale(point[1]),\n                }))\n\n                const layer: Omit<StreamLayerData, 'label' | 'color' | 'data'> = {\n                    id: keys[layerIndex] as string,\n                    path: areaGenerator(computedPoints) as string,\n                }\n\n                const layerWithComputedProperties: Omit<StreamLayerData, 'data'> = {\n                    ...layer,\n                    label: getLabel(layer),\n                    color: getColor(layer),\n                }\n\n                return {\n                    ...layerWithComputedProperties,\n                    data: computedPoints.map(point => {\n                        point.layerLabel = layerWithComputedProperties.label\n                        point.color = layerWithComputedProperties.color\n\n                        return point\n                    }),\n                }\n            }),\n        [layers, keys, getLabel, areaGenerator, getColor, xScale, yScale, formatValue]\n    )\n\n    const slices: StreamSliceData[] = useMemo(\n        () =>\n            Array.from({ length: data.length }, (_, i) => {\n                const sliceStack = enhancedLayers\n                    .map(layer => layer.data[i])\n                    .sort((a, b) => a.y2 - b.y2)\n\n                return {\n                    index: i,\n                    x: enhancedLayers[0].data[i].x,\n                    stack: sliceStack,\n                }\n            }),\n        [data.length, enhancedLayers]\n    )\n\n    const layerContext: StreamCustomLayerProps = useMemo(\n        () => ({\n            xScale,\n            yScale,\n            layers: enhancedLayers,\n            slices,\n        }),\n        [xScale, yScale, enhancedLayers, slices]\n    )\n\n    return {\n        xScale,\n        yScale,\n        layers: enhancedLayers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    }\n}\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { StreamDatum, StreamSvgProps } from './types'\nimport { Stream } from './Stream'\n\nexport const ResponsiveStream = <RawDatum extends StreamDatum>(\n    props: Omit<StreamSvgProps<RawDatum>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Stream<RawDatum> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"],"names":["StreamLayer","layer","fillOpacity","borderWidth","getBorderColor","isInteractive","tooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseHover","useCallback","event","createElement","useMotionConfig","animate","springConfig","config","animatedPath","useAnimatedPath","path","animatedProps","useSpring","color","immediate","_jsx","animated","d","fill","stroke","strokeWidth","onMouseMove","undefined","onMouseEnter","onMouseLeave","StreamLayers","layers","map","i","getDotY","datum","position","y","y2","y1","StreamDots","data","dotComponent","getSize","getColor","getBorderWidth","key","x","size","borderColor","StreamSlicesItem","slice","height","useState","isHover","setIsHover","handleMouseLeave","_jsxs","transform","x1","x2","strokeOpacity","width","StreamSlices","slices","index","defaultProps","label","order","offsetType","curve","axisBottom","axisLeft","enableGridX","enableGridY","colors","scheme","from","modifiers","enableDots","dotPosition","radius","circle","cx","cy","r","dotSize","dotColor","dotBorderWidth","dotBorderColor","BasicTooltip","id","enableChip","enableStackTooltip","stackTooltip","rows","useMemo","stack","p","Chip","layerId","layerLabel","formattedValue","TableTooltip","legends","legendLabel","role","svgDefaultProps","defs","motionConfig","isFocusable","InnerStream","keys","valueFormat","chartLayers","partialMargin","margin","axisTop","axisRight","ariaLabel","ariaLabelledBy","ariaDescribedBy","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","areaCurveFactory","useCurveInterpolation","areaGenerator","area","y0","d3Stack","offset","stackOffsetFromProp","stackOrderFromProp","allMin","allMax","point","push","value","minValue","Math","min","maxValue","max","scalePoint","domain","Array","length","_","range","scaleLinear","xScale","yScale","theme","useTheme","useOrdinalColorScale","useInheritedColor","getDotSize","getDotColor","getDotBorderWidth","getDotBorderColor","getLabel","usePropertyAccessor","formatValue","useValueFormatter","enhancedLayers","points","layerIndex","computedPoints","layerWithComputedProperties","sliceStack","sort","a","b","layerContext","useStream","boundDefs","bindDefs","layerById","grid","axes","dots","includes","Grid","Axes","top","right","bottom","left","Fragment","legend","legendData","reverse","BoxLegendSvg","containerWidth","containerHeight","SvgWrapper","Stream","renderWrapper","otherProps","Container","ResponsiveStream","props","ResponsiveWrapper"],"mappings":"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"}