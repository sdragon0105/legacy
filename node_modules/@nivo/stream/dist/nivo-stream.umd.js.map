{"version":3,"file":"nivo-stream.umd.js","sources":["../src/StreamLayer.tsx","../src/StreamLayers.tsx","../src/StreamDots.tsx","../src/StreamSlicesItem.tsx","../src/StreamSlices.tsx","../src/props.ts","../src/StreamDotsItem.tsx","../src/LayerTooltip.tsx","../src/StackTooltip.tsx","../src/hooks.ts","../src/Stream.tsx","../src/ResponsiveStream.tsx"],"sourcesContent":["import { useCallback, createElement } from 'react'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useAnimatedPath, useMotionConfig } from '@nivo/core'\nimport { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamLayerData } from './types'\n\ninterface StreamLayerProps<RawDatum extends StreamDatum> {\n    layer: StreamLayerData\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayer = <RawDatum extends StreamDatum>({\n    layer,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayerProps<RawDatum>) => {\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n    const handleMouseHover = useCallback(\n        event => {\n            showTooltipFromEvent(createElement(tooltip, { layer }), event, 'left')\n        },\n        [showTooltipFromEvent, layer]\n    )\n\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedPath = useAnimatedPath(layer.path)\n    const animatedProps = useSpring({\n        color: layer.color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.path\n            d={animatedPath}\n            fill={layer.fill ? layer.fill : animatedProps.color}\n            fillOpacity={fillOpacity}\n            stroke={getBorderColor(layer)}\n            strokeWidth={borderWidth}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? hideTooltip : undefined}\n        />\n    )\n}\n","import { InheritedColorConfigCustomFunction } from '@nivo/colors'\nimport { StreamLayer } from './StreamLayer'\nimport { StreamCommonProps, StreamLayerData, StreamDatum } from './types'\n\ninterface StreamLayersProps<RawDatum extends StreamDatum> {\n    layers: StreamLayerData[]\n    fillOpacity: number\n    borderWidth: number\n    getBorderColor: InheritedColorConfigCustomFunction<StreamLayerData>\n    isInteractive: boolean\n    tooltip: StreamCommonProps<RawDatum>['tooltip']\n}\n\nexport const StreamLayers = <RawDatum extends StreamDatum>({\n    layers,\n    fillOpacity,\n    borderWidth,\n    getBorderColor,\n    isInteractive,\n    tooltip,\n}: StreamLayersProps<RawDatum>) => (\n    <g>\n        {layers.map((layer, i) => (\n            <StreamLayer<RawDatum>\n                key={i}\n                layer={layer}\n                getBorderColor={getBorderColor}\n                borderWidth={borderWidth}\n                fillOpacity={fillOpacity}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n","import { createElement } from 'react'\nimport { StreamSvgProps, StreamLayerDatum, StreamDatum } from './types'\n\ninterface StreamDotsProps<RawDatum extends StreamDatum> {\n    id: string | number\n    color: string\n    data: StreamLayerDatum[]\n    dotComponent: Exclude<StreamSvgProps<RawDatum>['dotComponent'], undefined>\n    position: 'start' | 'center' | 'end'\n    getSize: (datum: StreamLayerDatum) => number\n    getColor: (datum: StreamLayerDatum) => string\n    getBorderWidth: (datum: StreamLayerDatum) => number\n    getBorderColor: (datum: StreamLayerDatum) => string\n}\n\nconst getDotY = <RawDatum extends StreamDatum>(\n    datum: StreamLayerDatum,\n    position: StreamDotsProps<RawDatum>['position']\n) => {\n    let y = datum.y2\n    if (position === 'center') {\n        y = datum.y1 + (datum.y2 - datum.y1) / 2\n    } else if (position === 'start') {\n        y = datum.y1\n    }\n\n    return y\n}\n\nexport const StreamDots = <RawDatum extends StreamDatum>({\n    data,\n    dotComponent,\n    position,\n    getSize,\n    getColor,\n    getBorderWidth,\n    getBorderColor,\n}: StreamDotsProps<RawDatum>) => (\n    <>\n        {data.map((datum, i) => {\n            return createElement(dotComponent, {\n                key: i,\n                datum,\n                x: datum.x,\n                y: getDotY<RawDatum>(datum, position),\n                size: getSize(datum),\n                color: getColor(datum),\n                borderWidth: getBorderWidth(datum),\n                borderColor: getBorderColor(datum),\n            })\n        })}\n    </>\n)\n","import { createElement, useCallback, useState } from 'react'\nimport { useTooltip } from '@nivo/tooltip'\nimport { StreamCommonProps, StreamDatum, StreamSliceData } from './types'\n\ninterface StreamSlicesItemProps<RawDatum extends StreamDatum> {\n    slice: StreamSliceData\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlicesItem = <RawDatum extends StreamDatum>({\n    slice,\n    height,\n    tooltip,\n}: StreamSlicesItemProps<RawDatum>) => {\n    const [isHover, setIsHover] = useState(false)\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        event => {\n            setIsHover(true)\n            showTooltipFromEvent(createElement(tooltip, { slice }), event, 'left')\n        },\n        [setIsHover, showTooltipFromEvent, tooltip, slice]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setIsHover(false)\n        hideTooltip()\n    }, [setIsHover, hideTooltip])\n\n    return (\n        <g transform={`translate(${slice.x}, 0)`}>\n            {isHover && (\n                <line\n                    x1={0}\n                    x2={0}\n                    y1={0}\n                    y2={height}\n                    stroke=\"#000\"\n                    strokeOpacity={0.35}\n                    strokeWidth={1}\n                />\n            )}\n            <rect\n                x={-20}\n                width={40}\n                height={height}\n                fill=\"#000\"\n                fillOpacity={0}\n                onMouseEnter={handleMouseHover}\n                onMouseMove={handleMouseHover}\n                onMouseLeave={handleMouseLeave}\n            />\n        </g>\n    )\n}\n","import { StreamSliceData, StreamDatum, StreamCommonProps } from './types'\nimport { StreamSlicesItem } from './StreamSlicesItem'\n\ninterface StreamSlicesProps<RawDatum extends StreamDatum> {\n    slices: StreamSliceData[]\n    height: number\n    tooltip: StreamCommonProps<RawDatum>['stackTooltip']\n}\n\nexport const StreamSlices = <RawDatum extends StreamDatum>({\n    slices,\n    height,\n    tooltip,\n}: StreamSlicesProps<RawDatum>) => (\n    <g>\n        {slices.map(slice => (\n            <StreamSlicesItem<RawDatum>\n                key={slice.index}\n                slice={slice}\n                height={height}\n                tooltip={tooltip}\n            />\n        ))}\n    </g>\n)\n","import { StackOrder, StackOffset, AreaCurve } from '@nivo/core'\nimport { StreamCommonProps, StreamLayerId } from './types'\nimport { StreamDotsItem } from './StreamDotsItem'\nimport { LayerTooltip } from './LayerTooltip'\nimport { StackTooltip } from './StackTooltip'\n\nexport const defaultProps = {\n    label: 'id',\n\n    order: 'none' as StackOrder,\n    offsetType: 'wiggle' as StackOffset,\n    curve: 'catmullRom' as AreaCurve,\n\n    axisBottom: {},\n    axisLeft: {},\n    enableGridX: false,\n    enableGridY: true,\n\n    colors: { scheme: 'nivo' } as StreamCommonProps<any>['colors'],\n    fillOpacity: 1,\n    borderWidth: 0,\n    borderColor: {\n        from: 'color',\n        modifiers: [['darker', 1]],\n    } as StreamCommonProps<any>['borderColor'],\n\n    enableDots: false,\n    dotPosition: 'center' as StreamCommonProps<any>['dotPosition'],\n    dotComponent: StreamDotsItem,\n    dotSize: 6,\n    dotColor: { from: 'color' },\n    dotBorderWidth: 0,\n    dotBorderColor: { from: 'color' },\n\n    isInteractive: true,\n    tooltip: LayerTooltip,\n    enableStackTooltip: true,\n    stackTooltip: StackTooltip,\n\n    legends: [],\n    legendLabel: 'id',\n\n    role: 'application',\n}\n\nexport const svgDefaultProps = {\n    ...defaultProps,\n    layers: ['grid', 'axes', 'layers', 'dots', 'slices', 'legends'] as StreamLayerId[],\n\n    defs: [],\n    fill: [],\n\n    animate: true,\n    motionConfig: 'default',\n\n    role: 'img',\n    isFocusable: false,\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\n\nexport interface StreamDotsItemProps {\n    x: number\n    y: number\n    size: number\n    color: string\n    borderWidth: number\n    borderColor: string\n}\n\nexport const StreamDotsItem = ({\n    x,\n    y,\n    size,\n    color,\n    borderWidth,\n    borderColor,\n}: StreamDotsItemProps) => {\n    const { animate, config: springConfig } = useMotionConfig()\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size * 0.5,\n        color,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.circle\n            cx={animatedProps.x}\n            cy={animatedProps.y}\n            r={animatedProps.radius}\n            fill={animatedProps.color}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n        />\n    )\n}\n","import { BasicTooltip } from '@nivo/tooltip'\nimport { TooltipProps } from './types'\n\nexport const LayerTooltip = ({ layer }: TooltipProps) => (\n    <BasicTooltip id={layer.label} enableChip={true} color={layer.color} />\n)\n","import { useMemo } from 'react'\nimport { TableTooltip, Chip } from '@nivo/tooltip'\nimport { StackTooltipProps } from './types'\n\nexport const StackTooltip = ({ slice }: StackTooltipProps) => {\n    const rows = useMemo(\n        () =>\n            slice.stack.map(p => [\n                <Chip key={p.layerId} color={p.color} />,\n                p.layerLabel,\n                p.formattedValue,\n            ]),\n        [slice]\n    )\n\n    return <TableTooltip rows={rows} />\n}\n","import { useMemo } from 'react'\nimport { area, stack as d3Stack } from 'd3-shape'\nimport { scaleLinear, scalePoint } from 'd3-scale'\nimport {\n    useTheme,\n    usePropertyAccessor,\n    useValueFormatter,\n    useCurveInterpolation,\n    // @ts-ignore\n    stackOrderFromProp,\n    // @ts-ignore\n    stackOffsetFromProp,\n} from '@nivo/core'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport {\n    StreamCommonProps,\n    StreamCustomLayerProps,\n    StreamDataProps,\n    StreamDatum,\n    StreamLayerData,\n    StreamLayerDatum,\n    StreamSliceData,\n} from './types'\nimport { defaultProps } from './props'\n\nexport const useStream = <RawDatum extends StreamDatum>({\n    width,\n    height,\n    data,\n    keys,\n    label = defaultProps.label,\n    valueFormat,\n    offsetType = defaultProps.offsetType,\n    order = defaultProps.order,\n    curve = defaultProps.curve,\n    colors = defaultProps.colors,\n    borderColor = defaultProps.borderColor,\n    dotSize = defaultProps.dotSize,\n    dotColor = defaultProps.dotColor,\n    dotBorderWidth = defaultProps.dotBorderWidth,\n    dotBorderColor = defaultProps.dotBorderColor,\n}: {\n    width: number\n    height: number\n    data: StreamDataProps<RawDatum>['data']\n    keys: StreamDataProps<RawDatum>['keys']\n    label?: StreamCommonProps<RawDatum>['label']\n    valueFormat?: StreamCommonProps<RawDatum>['valueFormat']\n    offsetType?: StreamCommonProps<RawDatum>['offsetType']\n    order?: StreamCommonProps<RawDatum>['order']\n    curve?: StreamCommonProps<RawDatum>['curve']\n    colors?: StreamCommonProps<RawDatum>['colors']\n    dotSize?: StreamCommonProps<RawDatum>['dotSize']\n    dotColor?: StreamCommonProps<RawDatum>['dotColor']\n    dotBorderWidth?: StreamCommonProps<RawDatum>['dotBorderWidth']\n    dotBorderColor?: StreamCommonProps<RawDatum>['dotBorderColor']\n    borderColor?: StreamCommonProps<RawDatum>['borderColor']\n}) => {\n    const areaCurveFactory = useCurveInterpolation(curve)\n    const areaGenerator = useMemo(\n        () =>\n            area<StreamLayerDatum>()\n                .x(({ x }) => x)\n                .y0(({ y1 }) => y1)\n                .y1(({ y2 }) => y2)\n                .curve(areaCurveFactory),\n        [areaCurveFactory]\n    )\n\n    const stack = useMemo(\n        () =>\n            d3Stack<RawDatum, string | number>()\n                .keys(keys)\n                .offset(stackOffsetFromProp(offsetType))\n                .order(stackOrderFromProp(order)),\n        [keys, offsetType, order]\n    )\n\n    const [layers, xScale, yScale] = useMemo(() => {\n        const allMin: number[] = []\n        const allMax: number[] = []\n\n        const layers = stack(data).map(layer => {\n            return layer.map(point => {\n                allMin.push(point[0])\n                allMax.push(point[1])\n\n                return {\n                    ...point,\n                    value: point.data[layer.key] as number,\n                }\n            })\n        })\n\n        const minValue = Math.min(...allMin)\n        const maxValue = Math.max(...allMax)\n\n        return [\n            layers,\n            scalePoint<number>()\n                .domain(Array.from({ length: data.length }, (_, i) => i))\n                .range([0, width]),\n            scaleLinear().domain([minValue, maxValue]).range([height, 0]),\n        ]\n    }, [stack, data, width, height])\n\n    const theme = useTheme()\n    const getColor = useOrdinalColorScale<Omit<StreamLayerData, 'label' | 'color' | 'data'>>(\n        colors,\n        'id'\n    )\n    const getBorderColor = useInheritedColor<StreamLayerData>(borderColor, theme)\n\n    const getDotSize = useMemo(\n        () => (typeof dotSize === 'function' ? dotSize : () => dotSize),\n        [dotSize]\n    )\n    const getDotColor = useInheritedColor(dotColor, theme)\n    const getDotBorderWidth = useMemo(\n        () => (typeof dotBorderWidth === 'function' ? dotBorderWidth : () => dotBorderWidth),\n        [dotBorderWidth]\n    )\n    const getDotBorderColor = useInheritedColor(dotBorderColor, theme)\n\n    const getLabel = usePropertyAccessor<\n        Omit<StreamLayerData, 'label' | 'color' | 'data'>,\n        string | number\n    >(label)\n    const formatValue = useValueFormatter(valueFormat)\n\n    const enhancedLayers: StreamLayerData[] = useMemo(\n        () =>\n            layers.map((points, layerIndex) => {\n                const computedPoints: StreamLayerDatum[] = points.map((point, i) => ({\n                    layerId: keys[layerIndex],\n                    layerLabel: '',\n                    index: i,\n                    color: '',\n                    x: xScale(i) as number,\n                    value: point.value,\n                    formattedValue: formatValue(point.value),\n                    y1: yScale(point[0]),\n                    y2: yScale(point[1]),\n                }))\n\n                const layer: Omit<StreamLayerData, 'label' | 'color' | 'data'> = {\n                    id: keys[layerIndex] as string,\n                    path: areaGenerator(computedPoints) as string,\n                }\n\n                const layerWithComputedProperties: Omit<StreamLayerData, 'data'> = {\n                    ...layer,\n                    label: getLabel(layer),\n                    color: getColor(layer),\n                }\n\n                return {\n                    ...layerWithComputedProperties,\n                    data: computedPoints.map(point => {\n                        point.layerLabel = layerWithComputedProperties.label\n                        point.color = layerWithComputedProperties.color\n\n                        return point\n                    }),\n                }\n            }),\n        [layers, keys, getLabel, areaGenerator, getColor, xScale, yScale, formatValue]\n    )\n\n    const slices: StreamSliceData[] = useMemo(\n        () =>\n            Array.from({ length: data.length }, (_, i) => {\n                const sliceStack = enhancedLayers\n                    .map(layer => layer.data[i])\n                    .sort((a, b) => a.y2 - b.y2)\n\n                return {\n                    index: i,\n                    x: enhancedLayers[0].data[i].x,\n                    stack: sliceStack,\n                }\n            }),\n        [data.length, enhancedLayers]\n    )\n\n    const layerContext: StreamCustomLayerProps = useMemo(\n        () => ({\n            xScale,\n            yScale,\n            layers: enhancedLayers,\n            slices,\n        }),\n        [xScale, yScale, enhancedLayers, slices]\n    )\n\n    return {\n        xScale,\n        yScale,\n        layers: enhancedLayers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    }\n}\n","import { createElement, Fragment, ReactNode } from 'react'\nimport {\n    Container,\n    SvgWrapper,\n    useDimensions,\n    // @ts-ignore\n    bindDefs,\n} from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { StreamLayers } from './StreamLayers'\nimport { StreamDots } from './StreamDots'\nimport { StreamSlices } from './StreamSlices'\nimport { useStream } from './hooks'\nimport { svgDefaultProps } from './props'\nimport { StreamDatum, StreamLayerId, StreamSvgProps } from './types'\n\ntype InnerStreamProps<RawDatum extends StreamDatum> = Omit<\n    StreamSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerStream = <RawDatum extends StreamDatum>({\n    data,\n    keys,\n    label,\n    valueFormat,\n\n    offsetType,\n    order,\n    curve,\n\n    layers: chartLayers = svgDefaultProps.layers,\n\n    width,\n    height,\n    margin: partialMargin,\n\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n\n    colors,\n    fillOpacity = svgDefaultProps.fillOpacity,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n\n    enableDots = svgDefaultProps.enableDots,\n    dotPosition = svgDefaultProps.dotPosition,\n    dotComponent = svgDefaultProps.dotComponent,\n    dotSize,\n    dotColor,\n    dotBorderWidth,\n    dotBorderColor,\n\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    enableStackTooltip = svgDefaultProps.enableStackTooltip,\n    stackTooltip = svgDefaultProps.stackTooltip,\n\n    legends = svgDefaultProps.legends,\n\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n}: InnerStreamProps<RawDatum>) => {\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const {\n        xScale,\n        yScale,\n        layers,\n        slices,\n        getBorderColor,\n        getDotSize,\n        getDotColor,\n        getDotBorderWidth,\n        getDotBorderColor,\n        layerContext,\n    } = useStream<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        keys,\n        label,\n        valueFormat,\n        offsetType,\n        order,\n        curve,\n        colors,\n        borderColor,\n        dotSize,\n        dotColor,\n        dotBorderWidth,\n        dotBorderColor,\n    })\n\n    const boundDefs = bindDefs(defs, layers, fill)\n\n    const layerById: Record<StreamLayerId, ReactNode> = {\n        grid: null,\n        axes: null,\n        layers: null,\n        dots: null,\n        slices: null,\n        legends: null,\n    }\n\n    if (chartLayers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (xScale as any) : null}\n                yScale={enableGridY ? (yScale as any) : null}\n            />\n        )\n    }\n\n    if (chartLayers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale as any}\n                yScale={yScale as any}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (chartLayers.includes('layers')) {\n        layerById.layers = (\n            <StreamLayers<RawDatum>\n                key=\"layers\"\n                layers={layers}\n                fillOpacity={fillOpacity}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n                isInteractive={isInteractive}\n                tooltip={tooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('dots') && enableDots) {\n        layerById.dots = (\n            <Fragment key=\"dots\">\n                {layers.map(layer => (\n                    <StreamDots\n                        key={layer.id}\n                        id={layer.id}\n                        color={layer.color}\n                        data={layer.data}\n                        dotComponent={dotComponent}\n                        position={dotPosition}\n                        getSize={getDotSize}\n                        getColor={getDotColor}\n                        getBorderWidth={getDotBorderWidth}\n                        getBorderColor={getDotBorderColor}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    if (chartLayers.includes('slices') && isInteractive && enableStackTooltip) {\n        layerById.slices = (\n            <StreamSlices<RawDatum>\n                key=\"slices\"\n                slices={slices}\n                height={innerHeight}\n                tooltip={stackTooltip}\n            />\n        )\n    }\n\n    if (chartLayers.includes('legends')) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, i) => {\n                    const legendData = layers\n                        .map(layer => ({\n                            id: layer.id,\n                            label: layer.label,\n                            color: layer.color,\n                            fill: layer.fill,\n                        }))\n                        .reverse()\n\n                    return (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legend}\n                            containerWidth={innerWidth}\n                            containerHeight={innerHeight}\n                            data={legendData}\n                        />\n                    )\n                })}\n            </Fragment>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {chartLayers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Stream = <RawDatum extends StreamDatum>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: StreamSvgProps<RawDatum>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerStream<RawDatum> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import { ResponsiveWrapper } from '@nivo/core'\nimport { StreamDatum, StreamSvgProps } from './types'\nimport { Stream } from './Stream'\n\nexport const ResponsiveStream = <RawDatum extends StreamDatum>(\n    props: Omit<StreamSvgProps<RawDatum>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Stream<RawDatum> width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n"],"names":["StreamLayer","layer","fillOpacity","borderWidth","getBorderColor","isInteractive","tooltip","useTooltip","showTooltipFromEvent","hideTooltip","handleMouseHover","useCallback","event","createElement","useMotionConfig","animate","springConfig","config","animatedPath","useAnimatedPath","path","animatedProps","useSpring","color","immediate","_jsx","animated","d","fill","stroke","strokeWidth","onMouseMove","undefined","onMouseEnter","onMouseLeave","StreamLayers","layers","map","i","getDotY","datum","position","y","y2","y1","StreamDots","data","dotComponent","getSize","getColor","getBorderWidth","key","x","size","borderColor","StreamSlicesItem","slice","height","useState","isHover","setIsHover","handleMouseLeave","_jsxs","transform","x1","x2","strokeOpacity","width","StreamSlices","slices","index","defaultProps","label","order","offsetType","curve","axisBottom","axisLeft","enableGridX","enableGridY","colors","scheme","from","modifiers","enableDots","dotPosition","radius","circle","cx","cy","r","dotSize","dotColor","dotBorderWidth","dotBorderColor","BasicTooltip","id","enableChip","enableStackTooltip","stackTooltip","rows","useMemo","stack","p","Chip","layerId","layerLabel","formattedValue","TableTooltip","legends","legendLabel","role","svgDefaultProps","defs","motionConfig","isFocusable","useStream","keys","valueFormat","areaCurveFactory","useCurveInterpolation","areaGenerator","area","y0","d3Stack","offset","stackOffsetFromProp","stackOrderFromProp","allMin","allMax","point","push","value","minValue","Math","min","maxValue","max","scalePoint","domain","Array","length","_","range","scaleLinear","xScale","yScale","theme","useTheme","useOrdinalColorScale","useInheritedColor","getDotSize","getDotColor","getDotBorderWidth","getDotBorderColor","getLabel","usePropertyAccessor","formatValue","useValueFormatter","enhancedLayers","points","layerIndex","computedPoints","layerWithComputedProperties","sliceStack","sort","a","b","layerContext","InnerStream","chartLayers","partialMargin","margin","axisTop","axisRight","ariaLabel","ariaLabelledBy","ariaDescribedBy","useDimensions","innerWidth","innerHeight","outerWidth","outerHeight","boundDefs","bindDefs","layerById","grid","axes","dots","includes","Grid","Axes","top","right","bottom","left","Fragment","legend","legendData","reverse","BoxLegendSvg","containerWidth","containerHeight","SvgWrapper","Stream","renderWrapper","otherProps","Container","props","ResponsiveWrapper"],"mappings":"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"}